# vim:syntax=zsh:ft=zsh

alias -g G='| egrep -i --color=always'
alias -g M="| $__LESS"
alias -g Y="| xsel"
alias -g iy="| xsel"

alias ...="../../"
alias ....="../../../"
alias cs="history 0"
alias mv="/bin/mv -i"
alias ll="/bin/ls --color=always -hFxtrl"
alias la="/bin/ls --color=always -hFXA"
alias ls="/bin/ls --color=always -hFv"
alias cp="cp -a"
alias rm="rm -r"
alias at="at -m"
alias ow="$__SUDO chown -R `whoami`:`whoami`"
alias diff="$__DIFF"
alias more="$__LESS"
alias tree="tree -C"
alias grep="grep --color=always"
alias egrep="egrep --color=always"
alias scp="scp -p"
alias lintian="lintian -viI"
alias tig="tig --all"
alias rsync="rsync -C"
alias rot13="tr a-zA-Z n-za-mN-ZA-M"

cd() {
    if builtin cd "$@"; then
        ls
    fi
}

## 但是 sudo 会导致各种强大插件出现安全问题
#vi() {
#    # 使用 :w !sudo tee % 虽然可以写入，但是会缺少 undolist
#    precommand=
#    for i in "$@" ; do
#        if [ -f "$i" -a ! -w "$i" ] ; then precommand=$__SUDO ; break ; fi
#    done
#
#    ${precommand} /usr/bin/vim -n "$@"
#}

md() {
    /bin/mkdir $*
    cd $1
}

tcp() {
    tar cpf - ${(@)argv[1, -2]} | tar xvf - -C ${argv[-1]}
}

T() { # tail
    if [ -r $*[$#] ]; then
        tail $*
    else
        $__SUDO tail $*
    fi
}

K() { # kill
    killall -u $USER $1
}

P() { # ps
    ps xf | grep -v "grep" | grep -B2 "$1"
}

PP() { # printer preview
    paps --landscape --font="monospace 8" --header --columns=2 $1 | ps2pdf - - | zathura -
}

PPP() {
    paps --landscape --font="monospace 8" --header --columns=2 $1 | lp -o landscape -o sites=two-sided-long-edge
}

/() { # find
    find ./ -iname "*$1*" ${(@)argv[2,$#]}
}

R() { # find in files
    egrep -ri --color=always \
        --exclude="*.old" --exclude="*.bak" --exclude="*.BAK" --exclude="*.orig" \
        --exclude="*.rej" --exclude="*.a" --exclude="*.olb" --exclude="*.o" \
        --exclude="*.obj" --exclude="*.so" --exclude="*.exe" --exclude="*.gz" \
        --exclude="*.tar" --exclude="*.zip" --exclude="*.tgz" --exclude="*.bz2" \
        --exclude="*.deb" --exclude="*.jar" --exclude="*.cab" --exclude="*.tbz" \
        --exclude="*.jpg" --exclude="*.jpeg" --exclude="*.png" --exclude="*.gif" \
        --exclude="*.pdf" --exclude-dir=".cscope" --exclude-dir=".svn" --exclude-dir=".git" \
        "$*" .
}

CS() { # gen cscope.files
    mkdir -p .cscope
    find . -iname '*.java' > .cscope/cscope_java.files
    find . -iname '*.c' -o -iname '*.cpp' -o -iname '*.cc' -o -iname '*.cxx' > .cscope/cscope_c.files
    find . -iname '*.h' -o -iname '*.hpp' -o -iname '*.hh' -o -iname '*.hxx' > .cscope/cscope_h.files
    cat .cscope/cscope_java.files .cscope/cscope_c.files .cscope/cscope_h.files > .cscope/cscope.files
    cscope -kbq -i.cscope/cscope.files -f.cscope/cscope.out
    ctags --c++-kinds=+p --fields=+iaS --extra=+q --tag-relative -L.cscope/cscope_java.files -f.cscope/cscope_java.tags
    ctags --c++-kinds=+p --fields=+iaS --extra=+q --tag-relative -L.cscope/cscope_c.files -f.cscope/cscope_c.tags
    ctags --c++-kinds=+p --fields=+iaS --extra=+q --tag-relative -L.cscope/cscope_h.files -f.cscope/cscope_h.tags
}

dup() { # dupload
    if echo "$1" | grep -q '\.changes$' ; then
        # dup *.changes
        /usr/bin/dupload $@
    else
        # dup 127 *.changes
        /usr/bin/dupload -t "$1" ${(@)argv[2,$#]}
    fi
}

# package {{{
DISTRO=`awk '/[[:alpha:]]/ { print $1; exit }' /etc/issue`
if [[ $DISTRO == "Debian" || $DISTRO == "Ubuntu" ]]; then
    alias api="$__SUDO apt-get install"
    alias apo="apt-get source"
    alias ape="vi /etc/apt/sources.list"
    alias apr="$__SUDO apt-get remove"
    alias apR="$__SUDO apt-get autoremove"
    alias apu="$__SUDO apt-get update"
    alias app="$__SUDO apt-get purge"
    alias apg="apt-cache search"
    alias aps="apt-cache show"
    alias apv="apt-cache policy"

    alias dpi="$__SUDO dpkg -i"
    alias dpp="$__SUDO dpkg -P"
    alias dpc="dpkg -c"
    alias dps="dpkg -I"
    alias dpo="dpkg -e"
    alias dpx="dpkg -x"
    alias dpg="dpkg -l | grep"
    alias dpG="dpkg -S"
    alias dpL="dpkg -L"
    dpH() { echo "$1 hold" | $__SUDO dpkg --set-selections }
    dpI() { echo "$1 install" | $__SUDO dpkg --set-selections }


    alias sl="$__SUDO tail -f /var/log/syslog"
elif [[ $DISTRO == "Fedora" || $DISTRO == "Red" ]]; then
    alias api="$__SUDO yum install"
    alias apa="$__SUDO yum clean all"
    alias apr="$__SUDO yum remove"
    alias apg="yum search"
    alias aps="yum info"

    alias dpi="$__SUDO rpm -iUfvh --replacefiles --replacepkgs --oldpackage"
    alias dpc="rpm -qpl"
    alias dps="rpm -qpi"
    alias dpg="rpm -qa | grep"
    alias dpL="rpm -ql"
    alias dps="rpm -qi"
    alias dpr="$__SUDO rpm -e"

    alias sl="$__SUDO tail -f /var/log/messages"
fi
# }}}

# task {{{
alias pu="python $TODO_DIR/opt/punch/Punch.py"
alias td="todo.sh"
alias tdE="vi $TODO_DIR/inbox.txt +\"set ft=asciidoc\""
alias tda="td add"
#alias tdr="td del"
alias tdR="td replace"
alias td0="td prepend"
alias td\$="td append"
alias tdg="td list"
alias tdgc="td archive"
alias tdG="td listall"
alias tdp="td pri"
alias tdP="td depri"
alias tdO="td listnotes 2>/dev/null"
alias tdl="td lf =(remind -s+4 $TODO_DIR/var/remind/index.rem)"
alias tdn="pu what"
tdc() {
    if [[ ${ARGC} > 1 ]]; then # 追加注释
        td$ ${1} "/* ${(@)argv[2,$#]} */" > /dev/null 2>&1
    fi
}
tdr() { # remember the milk
# depends: http://www.davidwaring.net/projects/rtm.html
# depends: http://www.rememberthemilk.com/
    idx=${1}
    if [[ ${idx} == "" ]]; then
        return
    fi
    inbox=$(echo "#0x5BCC0x58EB0x901A" | ascii2uni -q)

    rem=$(remind -s+4 $TODO_DIR/var/remind/index.rem | sed -n "${idx}p")
    rem_date=$(echo ${rem} | sed 's/\(^.\{10\}\).*/\1/' )
    rem_time=$(echo ${rem} | sed 's/.* \([0-9]\{1,2\}:[0-9]\{1,2\}[ap]m\) .*/\1/')
    rem_mesg=$(echo ${rem} | sed 's/.*\(\([ap]m\)\|\(\*\)\) \(.*\)/\4/g')

    if [[ ${rem_time} == ${rem} ]]; then # 没有时间信息
        rem_time=""
    fi

    if ! pgrep "python" | grep "rtm add"; then # todo
        (rtm add ${inbox} "${rem_date} ${rem_time} ${rem_mesg}" > /dev/null &)
    else
        echo "rtm: there is another running instance."
    fi
}
tde() {
    if [ -z ${1} ]; then
        loc=":normal M"
    else
        loc=":normal $1gg"
    fi
    REMD_FILE=$TODO_DIR/var/remind/index.rem
    vi +":e $DONE_FILE" +"normal Gzz" \
        +":sp $REMD_FILE" +":normal zz" \
        +":vs $TODO_FILE" +"${loc}"
}
tdb() { # 某项任务带来的突发问题 (I)ssue
    tda "(I) ${(@)argv[2,$#]} by:${1}" > /dev/null 2>&1
    tdp ${1} B # 该任务被切换到阻塞状态 (B)lock
}
tdo() {
    DESC=$(sed -n "${1}p" ${TODO_FILE})
    if echo ${DESC} | egrep -qi 'message-id:'; then
        MAIL=`echo ${DESC} | sed -e 's/.*message-id:<\([^@]*@[^ ]*\)>.*/\1/gi'`
        ${TODO_DIR}/opt/mutt/muttjump "${MAIL}"
    elif echo ${DESC} | egrep -qi 'note:'; then
        NOTE=`echo ${DESC} | sed -e 's/.*note:\([^ ]*\).*/\1/g'`
        td notesedit ${NOTE} 2> /dev/null
    fi
}
tds() { # 开始一项工作
    if [ -z ${1} ]; then # 如果没给参数，代表继续最近一次的任务
        RECENT=$(tail -1 ${TODO_DIR}/var/punch.dat | cut -f1 | sed "s/\*/\\\*/g") # 关照星号(*)
        TDID=$(sed -n "\|${RECENT}|"= ${TODO_FILE})
    else
        TDID=${1}
    fi

    if [ "x"${2} != "x" ]; then # 如果有第二参数，表示持续多个蕃茄钟
        TURN=$((${2}+0))
    else
        TURN=1
    fi

    python $TODO_DIR/opt/punch/Punch.py in ${TDID} | tail -1
    # 如果上一个工作周期还没结束，譬如前一项工作在周期内完成了，
    # 那么等这个工作闹钟自己结束，避免一个新工作闹钟被重复添加。
    if ! pgrep "pomodoro.sh" > /dev/null 2>&1; then
        DESC=$(sed -n "${TDID}p" ${TODO_FILE})
        (${TODO_DIR}/opt/pomodoro/pomodoro.sh ${DESC} ${TURN} &) # 放到后台
    fi
}
tdd() { # 完成一项工作
    WHAT=$(pu what | sed "s/Active task: \(.*\) (.* .*)$/\1/") # 当前正在进行的任务描述
    if [[ ${WHAT} != "No task is active." ]]; then
        python $TODO_DIR/opt/punch/Punch.py out
        TDID=$(td -p ls "${WHAT}" | head -1 | cut -d' ' -f1)
    fi

    if [[ ${ARGC} == 0 ]]; then # 如果没给参数，表示当前正在进行的任务被打断 [D]isturb
        pkill pomodoro.sh
        return
    else # 否则处理由第一个参数代表的任务
        TDID=${1}
        td do ${TDID} > /dev/null 2>&1
        if [[ ${ARGC} > 1 ]]; then # 完成时允许添加简短的注释
            td$ ${TDID} "/* ${(@)argv[2,$#]} */" > /dev/null 2>&1
        fi
    fi

    # 对于被 issue 阻塞了的任务，当该 issue 解决时，自动切换父任务状态为 (F)ixed
    if td -p ls " by:" | egrep -qi "^${TDID}"; then # 当前任务是 issue 类型(by:)的任务
        # 找到被它阻塞的父任务
        F_TDID=$(sed -n "${TDID}p" ${TODO_FILE} | egrep --color=never -o 'by:[0-9]+' | cut -d':' -f2)
        # 当前解决的 issue 任务是导致父任务阻塞的唯一任务
        if [[ $(grep -c "(I).*by:${F_TDID}" ${TODO_FILE}) == 1 ]]; then
            tdp ${F_TDID} F # 父任务切换到已修复 (F)ixed 状态
        fi
    fi
}
# }}}

# archive {{{
tgz() {
    name=`echo $1 | sed 's/\/*$//g'`
    tar -zcf "$name.tgz" $@
}
tgzz() {
    name=`echo $1 | sed 's/\/*$//g'`
    tar -zcf "$name.tgz" $@ --exclude=.cscope --exclude-vcs
}
tgx() {
    $__SUDO tar -zxvf $@
}
tgg() {
    tar -tf $@
}

tjz() {
    name=`echo $1 | sed 's/\/*$//g'`
    tar -jcf "$name.tbz" $@
}
tjzz() {
    name=`echo $1 | sed 's/\/*$//g'`
    tar -jcf "$name.tbz" $@ --exclude=.cscope --exclude-vcs
}
tjx() {
    $__SUDO tar -jxvf $@
}
tjg() {
    tar -tf $@
}
# }}}

# file {{{
alias -s png="qiv -p -l"
alias -s PNG="qiv -p -l"
alias -s gif="qiv -p -l"
alias -s GIF="qiv -p -l"
alias -s jpg="qiv -p -l"
alias -s JPG="qiv -p -l"
alias -s bmp="qiv -p -l"
alias -s BMP="qiv -p -l"
alias -s xpm="qiv -p -l"
alias -s XPM="qiv -p -l"
alias -s jpeg="qiv -p -l"
alias -s JPEG="qiv -p -l"
alias -s icon="qiv -p -l"
alias -s ICON="qiv -p -l"

alias -s doc=c_doc
alias -s xls=c_xls
alias -s pdf="zathura"
alias -s html=c_htm

c_doc() { antiword $1 | less }
c_xls() { xlhtml $1 | w3m -T text/html }
c_pdf() { pdftotext -q $1 - | less }
c_htm() { w3m -T text/html $1 }
# }}}

# md5sum {{{
g256() {
    md5sum $* | gpg --digest-algo sha256 --clearsign
}
# }}}
